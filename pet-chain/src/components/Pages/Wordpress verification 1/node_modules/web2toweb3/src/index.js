const crypto = require('crypto');
const axios = require('axios');
const { v4: uuidv4 } = require('uuid');
const FormData = require('form-data');

const ContractABI = require('./abi.json');
const W2W3Config = require('./config.json');
const {PluginVersion, BlockchainHostURL, BlockchainExplorerURL, APIHostURL, ContractAddress} = W2W3Config;
const Web3 = require('web3');
const web3 = new Web3(BlockchainHostURL);
const W2W3Contract = new web3.eth.Contract(ContractABI, ContractAddress, {handleRevert:true});


function checkJSON(blockJSON)
{
	try
	{
		const parsed = JSON.parse(blockJSON)
		if (parsed && typeof parsed === "object") {
			return true;
		}
	}catch
	{
		return false;
	}
	return false
}


function _throw(error)
{
	throw new Error(error);
}


async function signTransaction(ClientID, SigningPrivateKey, UniqueTxID, blockJSON)
{
	try {
		const SigningAccount = web3.eth.accounts.privateKeyToAccount(SigningPrivateKey).address;

		try {
			const CheckTransaction = await W2W3Contract.methods.writeblock(ClientID, UniqueTxID, blockJSON).call({'from':SigningAccount});
		}catch(error)
		{
			return {txstatus:false, error:error.toString()};
		}
		
		const Transaction = await W2W3Contract.methods.writeblock(ClientID, UniqueTxID, blockJSON);
		
		const options = {
			to: Transaction._parent._address,
			data: Transaction.encodeABI(),
			gas: await Transaction.estimateGas({ from: SigningAccount })
		};

		const SignedTransaction = await web3.eth.accounts.signTransaction(options, SigningPrivateKey);

		if(SignedTransaction.rawTransaction)
		{
			return {txstatus:true, rawTransaction:SignedTransaction.rawTransaction};
		}
		else
		{
			return {txstatus:false, error:"unable to sign transaction"};
		}
		

	}catch(error)
	{
		return {txstatus:false, error:error.toString()};
	}
}


async function writeBlockData(_ClientID, _SigningPrivateKey, _UniqueTxID, _blockJSON, _blockFiles)
{
	try {
		const ClientID = _ClientID || _throw("Parameter ClientID is missing");
		const SigningPrivateKey = _SigningPrivateKey || _throw("Parameter SigningPrivateKey is missing");
		const UniqueTxID = _UniqueTxID || _throw("Parameter UniqueTxID is missing");
		var blockJSON = _blockJSON || _throw("Parameter blockJSON is missing");

		try
		{
			blockJSON = JSON.parse(blockJSON)
		}catch(error)
		{
			_throw("Parameter blockJSON is not a valid JSON");
		}
		
		const form = new FormData();
		
		var blockFiles = _blockFiles;
		var Files = [];

		if(blockFiles)
		{
			for(var i=0; i<blockFiles.length; i++)
			{
				const originalname = blockFiles[i].originalname;
				const fileext = originalname.substring(originalname.lastIndexOf('.'), originalname.length) || "";
				const uniquefilename = uuidv4()+fileext;
				
				form.append("blockFiles", blockFiles[i].buffer, { filename:uniquefilename })
				
				const Hash = crypto.createHash('sha256').update(blockFiles[i].buffer);
				const FileHash = Hash.digest('hex')
				
				const File = {FileName:uniquefilename, OrginalFileName:originalname, FileHash:FileHash};
				Files.push(File);
			}
		}
		
		if(Files.length>0)
		{
			blockJSON.Files=Files;
		}

		blockJSON = JSON.stringify(blockJSON);

		const SigningAccount = web3.eth.accounts.privateKeyToAccount(SigningPrivateKey).address;
		const TransStatus = await signTransaction(ClientID, SigningPrivateKey, UniqueTxID, blockJSON);

		if(TransStatus.txstatus)
		{
			const RawTransaction = TransStatus.rawTransaction;
			
			form.append('ClientID', ClientID);
			form.append('UniqueTxID', UniqueTxID);
			form.append('blockJSON', JSON.stringify(blockJSON));
			form.append('RawTransaction', RawTransaction);
			form.append('SigningAccount', SigningAccount);

			const response = await axios.post(APIHostURL+"/writeBlockData", form, {
				headers: {
				  'Content-Type': 'multipart/form-data'
				}
			});

			if (response.status === 200) {
				return response.data;
			}
			else
			{
				return {txstatus:false, error:"unable to complete the transaction"};
			}
		}
		else
		{
			return TransStatus;
		}
	
	} catch(error) {
		return {txstatus:false, error:error.toString()};
	}

}


async function readBlockData(_ClientID, _SigningPrivateKey, _UniqueTxID)
{

	try {
		const ClientID = _ClientID || _throw("Parameter ClientID is missing");
		const SigningPrivateKey = _SigningPrivateKey || _throw("Parameter SigningPrivateKey is missing");
		const UniqueTxID = _UniqueTxID || _throw("Parameter UniqueTxID is missing");
		const SigningAccount = web3.eth.accounts.privateKeyToAccount(SigningPrivateKey).address;

		try {
			
			const form = new FormData();

			form.append('ClientID', ClientID);
			form.append('UniqueTxID', UniqueTxID);
			form.append('SigningAccount', SigningAccount);

			const response = await axios.post(APIHostURL+"/readBlockData", form, {
				headers: {
				  'Content-Type': 'multipart/form-data'
				}
			});

			if (response.status === 200) {
				return response.data;
			}
			else
			{
				return {txstatus:false, error:"unable to complete the read request"};
			}

		}catch(error)
		{
			return {txstatus:false, error:error.toString()};
		}
		
	} catch(error) {
		return {txstatus:false, error:error.toString()};
	}

}


async function viewFile(_ClientID, _FileName, _FileHash)
{

	try {
		
		const ClientID = _ClientID || _throw("Parameter ClientID is missing");
		const FileName = _FileName || _throw("Parameter FileName is missing");
		const FileHash = _FileHash || _throw("Parameter FileHash is missing");

		try {
			
			const form = new FormData();
			form.append('ClientID', ClientID);
			form.append('FileName', FileName);
			form.append('FileHash', FileHash);

			const response = await axios.post(APIHostURL+"/viewFile", form, {
				responseType: "arraybuffer",
				headers: {
				  'Content-Type': 'multipart/form-data'
				}
			});

			if (response.status === 200) {
				return response.data;
			}
			else
			{
				return {txstatus:false, error:"unable to read file"};
			}

		}catch(error)
		{
			return {txstatus:false, error:error.toString()};
		}
		
	} catch(error) {
		return {txstatus:false, error:error.toString()};
	}

}


module.exports = {
	writeBlockData, readBlockData, viewFile, BlockchainExplorerURL
}